#!/usr/bin/env node
const firebase = require('firebase');
const Base64 = require('js-base64/base64.js').Base64;
const google = require('googleapis');
const googleAuth = require('google-auth-library');
require('firebase/database');

const STATIC_MONTHLY_BILLS = {
  rent: '2100.00',
  cable: '65.03'
};
const USER_SCOPED_BILLS = ['rent'];
const BILL_EMAIL_ADDRESSES = {
  utilities: 'do-not-reply@coautilities.com',
  gas: 'ebill@texasgasservice.com'
};
const FIREBASE_CONFIG = {
  apiKey: process.env.FIREBASE_CONFIG_APIKEY,
  authDomain: process.env.FIREBASE_CONFIG_AUTHDOMAIN,
  databaseURL: process.env.FIREBASE_CONFIG_DATABASEURL,
  storageBucket: process.env.FIREBASE_CONFIG_STORAGEBUCKET,
  messagingSenderId: process.env.FIREBASE_CONFIG_MESSAGINGSENDERID
}
const OAUTH_CONFIG = process.env.OAUTH_CONFIG.split(',');
const ROOMMATE_ADDRESSES = {
  adam: 'asgilroy@gmail.com',
  reba: 'rebeccaannn@gmail.com',
  sarah: 'sarahjeanbigelow@gmail.com',
  travis: 'travisryanbenton@gmail.com'
}

firebase.initializeApp(FIREBASE_CONFIG);

// firebase actions
function saveOwedBill(type, total, date, cb) {
  firebase.database().ref(`api/`).once('value')
    .then(resp => {
      const bills = resp.val().bills[date];
      const roommates = resp.val().users;
      const payload = Object.assign(STATIC_MONTHLY_BILLS, { [type]: total });
      const sendEmail = Object.keys(BILL_EMAIL_ADDRESSES).every(bill => (bills || {})[bill] || (bills || {})[type]);

      console.log("======= Do we send an email? ========")
      console.log(Object.keys(Object.keys(BILL_EMAIL_ADDRESSES)))
      console.log(bills)
      console.log(Object.keys(BILL_EMAIL_ADDRESSES).every(bill => (bills || {})[bill]))
      console.log("=====================================")

      if (!bills) {
        firebase.database().ref(`api/bills/${date}/`).set(payload);
      } else if (!(bills || {})[type]) {
        firebase.database().ref(`api/bills/${date}/${type}`).set(total);
      }

      if (sendEmail) {
        Object.keys(roommates).forEach(roommate => {
          cb(roommates, roommate, type, total, date, payload);
        });
      }
    });
};

function saveTokens(tokens) {
  firebase.database().ref('tokens/').set({
    access_token: tokens.access_token,
    refresh_token: tokens.refresh_token
  });
}

console.log('Loading Firebase...');

// google api
firebase.database().ref('tokens/').once('value').then(resp => {
  console.log('Firebase loaded');

  const ACCESS_TOKEN = resp.val().access_token;
  const REFRESH_TOKEN = resp.val().refresh_token;
  const scope = [
    'https://www.googleapis.com/auth/gmail.readonly',
    'https://www.googleapis.com/auth/gmail.compose'
  ];
  const oauth2Client = new google.auth.OAuth2(...OAUTH_CONFIG);
  const gmail = google.gmail('v1');

  function setCreds(access_token, refresh_token) {
    oauth2Client.setCredentials({
      access_token,
      refresh_token,
      token_type: 'Bearer'
    });
  }

  function updateCreds(emails, cb) {
    oauth2Client.refreshAccessToken((err, tokens) => {
      if (err) {
        console.log(err);
        return false;
      }
      saveTokens(tokens);
      setCreds(tokens.access_token, tokens.refresh_token);
      cb(BILL_EMAIL_ADDRESSES.utilities);
    });
  }

  function parseEmail(message) {
    const parts = message.payload.parts;
    let part;

    if (!parts) {
      part = {};
      part.body = message.payload.body
    } else {
      part = parts.filter(part => part.mimeType == 'text/html')[0];

      // in the case there are no text/html parts, check for
      // multipart/alternative... sort of a gross workaround
      if (!part) {
        part = message.payload.parts.filter(part => part.mimeType == 'multipart/alternative')[0].parts.filter(part => part.mimeType == 'text/html')[0];
      }
    }

    return new Buffer(part.body.data.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString();
  }

  function sendMessage(auth, roommates, roommate, type, price, date, payload) {
    let email = '';
    const headers = {
      // 'To': 'travisryanbenton@gmail.com',
      To: ROOMMATE_ADDRESSES[roommate],
      'Subject': 'Darlington Bills',
      'Reply-to': 'travisryanbenton@gmail.com',
      'From': 'travisryanbenton@gmail.com',
      'Content-type': 'text/html'
    }
    const message = () => {
      const name = roommate[0].toUpperCase() + roommate.slice(1);
      let total = 0;

      return `
        Hi ${name}, some bills came in for ${date}:<br/>
        ${Object.keys(payload).map(type => {
          let billAmt;

          if (USER_SCOPED_BILLS.indexOf(type) !== -1) {
            billAmt = parseInt(roommates[roommate][type], 10);
          } else {
            billAmt = parseInt(payload[type], 10)/4;
          }

          total += billAmt;
          return `<a href="https://cash.me/$travisbenton/${billAmt}">$${billAmt} for ${type}</a><br>`
        }).join('')}
        Or you could pay the total ($${total}) by clicking <a href="https://cash.me/$travisbenton/${total}">here</a>
      `
    }

    console.log('sending email with these headers:');
    console.log(headers);

    for (let header in headers) {
      email += header += ": "+headers[header]+"\r\n";
    }
    email += "\r\n" + message();
    const base64EncodedEmail = Base64.encodeURI(email);

    gmail.users.messages.send({
      auth,
      userId: 'me',
      prettyPrint: true,
      resource: {
        raw: base64EncodedEmail
      }
    }, (err, msg) => {
      if (err) {
        console.log(err);
      } else {
        console.log(msg);
        console.log('email sent!');
      }
    });
  }

  function parseBill(type, message, auth) {
    const html = parseEmail(message);
    const totalOwed = ((parseFloat(html.split('$')[1].split('<')[0], 10))).toFixed(2);
    const date = new Date(parseInt(message.internalDate, 10));

    // if I get the email later in the month, assume its for the following month
    const month = date.getDate() < 10 ? date.getMonth() + 1 : date.getMonth() + 2;
    const billDate = `${month}-${date.getFullYear()}`;

    console.log('---------=======--------');
    console.log(`${type} bill for the month of ${month}: $${totalOwed}`);
    console.log('---------=======--------');

    saveOwedBill(type, totalOwed, billDate,
      (roommates, roommate, type, price, date, payload) => {
        console.log('===================')
        console.log(roommates)
        console.log(roommate)
        console.log('===================')
        sendMessage(auth, roommates, roommate, type, price, date, payload);
      }
    );
  }

  function parseBills(emails, type) {
    gmail.users.messages.get({
      auth: oauth2Client,
      'userId': 'me',
      'id': emails.messages[0].id,
      'format': 'full'
    }, (err, message) => parseBill(type, message, oauth2Client));
  }

  function listRecentEmailsByAccount(account, type) {
    gmail.users.messages.list({
      auth: oauth2Client,
      userId : 'me',
      q : `from:${account}`
    }, (err, resp) => {
      if (err) {
        console.log('error!');
        console.log(err);
        return updateCreds(resp, () => listRecentEmailsByAccount(account, type));
      }
      console.log('parsing bill emails');
      return parseBills(resp, type);
    });
  }

  setCreds(ACCESS_TOKEN, REFRESH_TOKEN);
  Object.keys(BILL_EMAIL_ADDRESSES).forEach(type =>
    listRecentEmailsByAccount(BILL_EMAIL_ADDRESSES[type], type)
  );
});
